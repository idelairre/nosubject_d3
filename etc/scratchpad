fetchCategory(title) {
  for (let i = categories.length; i -= 1;) {
    if (categories[i].title === title) {
      return categories[i];
    }
  }
}

async generateCategoryNodes(title) {
  try {
    let category = await this.fetchCategory(title);
    let links = [], nodes = [];
    let rootNode = {
      label: category.title
    };
    nodes.push(rootNode);
    for (let i = category.articles.length; i -= 1;) {
      let article = category.articles[i].title
      let node = {
        label: article
      };
      nodes.push(node);
    }
    for (let i = category.articles.length; i -= 1;) {
      for (let j = nodes.length; j -= 1;) {
        if (nodes[j].label !== rootNode.label) {
          links.push({
            source: rootNode,
            target: nodes[j]
          });
        }
      }
    }
    // this.checkNodes(nodes, links)
    let data = {
      nodes: nodes,
      links: links
    };
    return data;
  } catch (error) {
    throw error;
  }
}

import alt from '../alt';
import ChartActions from '../actions/chartActions';
import graphGenerator from '../generator/graphGenerator';
import { AsyncDispatch } from 'alt-async';

class CategoryNodeGenerator extends AsyncDispatch {
  constructor(dispatcher, name) {
    super(dispatcher, name);
  }

  generateCategoryNodes(title) {
    return this.send(null, status => {
        return graphGenerator.generateCategoryNodes(title);
    }, {
      success: ChartActions.generatedNodes,
      failure: ChartActions.generatingNodesFailed
    });
  }
}

const categoryNodeGenerator = new CategoryNodeGenerator(alt, "CategoryNodeGenerator");

export default categoryNodeGenerator;

async generateArticleBacklinksJSON() {
  return fsp.readdir('./output/backlinks', async (error, articles) => {
    if (error) {
      console.error(error);
    }
    let i = 0
    let requests = articles.length;
    let jsonArray = [];
    let pace = require('pace')(articles.length);
    while (articles.length > i) {
      i += 1;
      let article = articles[i];
      let backlinks = await this.generateBacklinkJSON(article);
      jsonArray.push(backlinks);
      if (backlinks) {
        requests -= 1;
        pace.op();
      }
      if (requests === 0) {
        console.log('json array:', jsonArray);
        fsp.writeFile('output/backlinks.json', JSON.stringify(jsonArray, null, 3), (error) => {});
      }
    }
  });
}


  generateArticleBacklinkJSON(article, links) {
    return new Promise((resolve, reject) => {
      let json = {
        title: article.replace(/.json/, ''),
        links: JSON.parse(line)
      };
      resolve(json);
    });
  }

  async generateCategoryDatabase() {
    let categories = await this.getCategories();
    let categoriesArray = [];
    let requests = 0;
    let i = 0
    while (categories.length > i) {
      i += 1;
      let categoryHash = {
        title: null,
        articles: []
      };
      categoryHash.title = categories[i];
      console.log(categories[i]);
      requests += 1;
      this.getArticlesInCategory(categories[i]).then((response) => {
        requests -= 1;
        categoryHash.articles = response;
        categoryHash.articles.map((article) => {
          article.title = fixUtf8(article.title);
          console.log('pushing ', article.title, ', ', requests, ' articles left');
        });
        categoriesArray.push(categoryHash);
        if (requests === 0) {
          fsp.writeFile('./output/categories.json', JSON.stringify(categoriesArray, null, 3), (error) => {
            console.log(error);
          });
        }
      });
    }
  }

  let catQuestions = [{
    type: 'list',
    name: 'categories',
    message: 'Which category do you want to view?',
    choices: formattedCategories
  }];
  this.fetchCategories()
      .then(categories => this.formatCategories(formattedCategories))
      .then(formattedCategories => inquirer.prompt(catQuestions, (catAnswers) => {
        this.fetchArticlesInCategory(catAnswers.category)
            .then(articles => this.generateArticleIndex(articles))
            .then(formattedArticles => console.log(formattedArticles));
          }));


getArticle(article) {
  return new Promise((resolve, reject) => {
    this.client.getArticle(article, (error, data) => {
      if (error) {
        reject(error);
        return;
      }
      resolve(data);
    });
  });
}


  fetchArticlesInCategory(category) {
    return new Promise((resolve, reject) => {
      this.client.getPagesInCategory(category, (error, data) => {
        if (error) {
          reject(error);
          return;
        }
        data = JSON.parse(fixUtf8(JSON.stringify(data)));
        resolve(data);
      });
    });
  }

  formatCategories(categories) {
    return new Promise((resolve, reject) => {
      try {
        for (let i in categories) {
          categories[i] = fixUtf8(categories[i]);
        }
        categories = categories.sort((a, b) => {
          return a.toLowerCase() - b.toLowerCase();
        });
        categories = categories.filter(function(item, pos) {
          return categories.indexOf(item) == pos;
        })
        resolve(categories);
      } catch (error) {
        reject(error);
      }
    });
  }

  fetchCategories() {
    return new Promise((resolve, reject) => {
      this.client.getCategories((error, data) => {
        if (error) {
          reject(error);
          return;
        }
        resolve(data);
      });
    });
  }

  fetchArticleCategories(article) {
    return new Promise((resolve, reject) => {
      this.client.getArticleCategories(article, (error, data) => {
        if (error) {
          reject(error);
          return;
        }
        let categories = JSON.parse(fixUtf8(JSON.stringify(data)));
        resolve(categories);
      });
    });
  }
